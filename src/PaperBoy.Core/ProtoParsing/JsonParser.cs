using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using Google.Protobuf;
using Google.Protobuf.Reflection;
using Microsoft.Extensions.Logging;
using PaperBoy.Core.ProtoParsing.Models;

namespace PaperBoy.Core.ProtoParsing;

public partial class JsonParser
{
    private const short RecursionLimit = 25;

    private readonly JsonSerializerOptions _jsonSerializerOptions = new()
    {
        WriteIndented = true
    };

    private readonly ILogger<JsonParser> _logger;

    public JsonParser(ILogger<JsonParser> logger)
    {
        _logger = logger;
    }

    /// <summary>
    ///     Reads bytes from proto descriptor generated by protoc-util. Returns JSON-like string represented original proto
    ///     with stubbed values. Not using CLR classes from protoc.
    /// </summary>
    /// <param name="protoDescriptor">Proto descriptor in bytes.</param>
    /// <returns>Proto contract as JSON-string.</returns>
    public string ParseToJsonWithStub(byte[] protoDescriptor)
    {
        FileDescriptorSet fileDescriptorSet = FileDescriptorSet.Parser.ParseFrom(protoDescriptor);

        IReadOnlyList<FileDescriptor> fileDescriptor =
            FileDescriptor.BuildFromByteStrings(fileDescriptorSet.File.Select(x => x.ToByteString()));

        var parsedServiceDescriptor =
            new ServiceSerializationModel(new Dictionary<string, Dictionary<string, Dictionary<string, object>>>());

        foreach (FileDescriptor descriptor in fileDescriptor)
        {
            if (descriptor.Services.Count > 0)
            {
                foreach (ServiceDescriptor service in descriptor.Services)
                {
                    Dictionary<string, Dictionary<string, object>> parsedMethods = new();
                    parsedServiceDescriptor.ProtoService.Add(service.FullName, parsedMethods);

                    foreach (MethodDescriptor method in service.Methods)
                    {
                        object sampleRequest = CreateDefaultMessage(method.InputType);
                        object sampleResponse = CreateDefaultMessage(method.OutputType);

                        parsedMethods.Add(
                            method.Name,
                            new Dictionary<string, object>(2)
                            {
                                { method.InputType.FullName, sampleRequest },
                                { method.OutputType.FullName, sampleResponse }
                            }
                        );
                    }
                }

                return JsonSerializer.Serialize(parsedServiceDescriptor.ProtoService, _jsonSerializerOptions);
            }

            if (_logger.IsEnabled(LogLevel.Debug))
            {
                _logger.LogDebug(
                    "No service definitions was found in descriptor. Trying to parse stand alone messages.");
            }

            List<object> parsedMessages = new();

            foreach (MessageDescriptor message in descriptor.MessageTypes)
            {
                parsedMessages.Add(CreateDefaultMessage(message));
            }

            return JsonSerializer.Serialize(parsedMessages, _jsonSerializerOptions);
        }

        return string.Empty;
    }


    internal static IMessage CreateDefaultMessageForClrTypes(MessageDescriptor descriptor)
    {
        var message = (IMessage)Activator.CreateInstance(descriptor.ClrType);

        foreach (FieldDescriptor field in descriptor.Fields.InDeclarationOrder())
        {
            object value = CreateDefaultValue(field, 0);

            if (field.IsRepeated)
            {
                var list = (IList)field.Accessor.GetValue(message);
                list.Add(value);
            }
            else
            {
                field.Accessor.SetValue(message, value);
            }
        }

        return message;
    }

    private static object CreateDefaultMessage(MessageDescriptor descriptor, int recursionDepth = 0)
    {
        if (recursionDepth > RecursionLimit)
        {
            return null;
        }

        Dictionary<string, object> obj = new();

        foreach (FieldDescriptor field in descriptor.Fields.InDeclarationOrder())
        {
            object value = CreateDefaultValue(field, recursionDepth);

            if (field.IsRepeated)
            {
                obj[field.Name] = new List<object> { value };
            }
            else
            {
                obj[field.Name] = value;
            }
        }

        return obj;
    }

    private static object CreateDefaultValue(FieldDescriptor field, int depth)
    {
        switch (field.FieldType)
        {
            case FieldType.String:
                return "string value example";

            case FieldType.Int32:
            case FieldType.SInt32:
            case FieldType.SFixed32:
                return 123;

            case FieldType.Int64:
            case FieldType.SInt64:
            case FieldType.SFixed64:
                return 123456789L;

            case FieldType.UInt32:
            case FieldType.Fixed32:
                return 123u;

            case FieldType.UInt64:
            case FieldType.Fixed64:
                return 123456789UL;

            case FieldType.Bool:
                return true;

            case FieldType.Double:
                return 1.23;

            case FieldType.Float:
                return 1.23f;

            case FieldType.Bytes:
                return ByteString.CopyFromUtf8("bytes");

            case FieldType.Enum:
                return field.EnumType.Values.First().Number;

            case FieldType.Message:
                return CreateDefaultMessage(field.MessageType);

            default:
                return null;
        }
    }

    [LoggerMessage(LogLevel.Debug, "Method: {methodName}")]
    partial void LogMethodMethodName(string methodName);

    [LoggerMessage(LogLevel.Debug, "Service: {serviceFullName}")]
    partial void LogServiceFullName(string serviceFullName);

    [LoggerMessage(LogLevel.Debug, "Request Type: {inputTypeFullName}")]
    partial void LogRequestTypeInputTypeFullname(string inputTypeFullName);
}